-- Billing Tables for Stripe Integration
-- Generated by Supabase Migration Agent

-- =====================================================
-- 1. SUBSCRIPTIONS TABLE
-- =====================================================

CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  stripe_subscription_id TEXT UNIQUE,
  stripe_customer_id TEXT,
  plan_tier TEXT NOT NULL CHECK (plan_tier IN ('free', 'individual', 'pro', 'team')),
  status TEXT NOT NULL CHECK (status IN ('active', 'canceled', 'past_due', 'trialing', 'incomplete', 'incomplete_expired', 'unpaid')),
  current_period_start TIMESTAMPTZ,
  current_period_end TIMESTAMPTZ,
  cancel_at_period_end BOOLEAN DEFAULT false,
  canceled_at TIMESTAMPTZ,
  trial_start TIMESTAMPTZ,
  trial_end TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_stripe_subscription_id ON subscriptions(stripe_subscription_id);
CREATE INDEX idx_subscriptions_stripe_customer_id ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_plan_tier ON subscriptions(plan_tier);

-- Enable RLS
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;

-- Users can read their own subscription
CREATE POLICY "subscriptions_select_own"
  ON subscriptions
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- Only system can insert/update/delete (via service role)
-- Admins can read all subscriptions
CREATE POLICY "subscriptions_select_admin"
  ON subscriptions
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_subscriptions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER subscriptions_updated_at
  BEFORE UPDATE ON subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION update_subscriptions_updated_at();

COMMENT ON TABLE subscriptions IS 'User subscription data from Stripe';

-- =====================================================
-- 2. USAGE_EVENTS TABLE
-- =====================================================

CREATE TABLE usage_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  feature TEXT NOT NULL CHECK (feature IN ('live-call', 'practice', 'email', 'analyzer')),
  event_type TEXT NOT NULL CHECK (event_type IN ('api_call', 'duration', 'generation', 'analysis')),
  quantity NUMERIC NOT NULL DEFAULT 1,
  tokens_used INTEGER,
  cost_usd NUMERIC(10, 6),
  metadata JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_usage_events_user_id ON usage_events(user_id);
CREATE INDEX idx_usage_events_feature ON usage_events(feature);
CREATE INDEX idx_usage_events_created_at ON usage_events(created_at DESC);
CREATE INDEX idx_usage_events_user_feature_date ON usage_events(user_id, feature, created_at DESC);
CREATE INDEX idx_usage_events_metadata ON usage_events USING gin(metadata);

-- Enable RLS
ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;

-- Users can read their own events
CREATE POLICY "usage_events_select_own"
  ON usage_events
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- System can insert events (via service role)
-- Admins can read all events
CREATE POLICY "usage_events_select_admin"
  ON usage_events
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

COMMENT ON TABLE usage_events IS 'AI usage tracking for billing and analytics';

-- =====================================================
-- 3. USAGE_LIMITS TABLE
-- =====================================================

CREATE TABLE usage_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  plan_tier TEXT UNIQUE NOT NULL CHECK (plan_tier IN ('free', 'individual', 'pro', 'team')),
  monthly_live_call_minutes INTEGER,
  monthly_practice_sessions INTEGER,
  monthly_emails INTEGER,
  monthly_analyses INTEGER,
  features_enabled JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE usage_limits ENABLE ROW LEVEL SECURITY;

-- Everyone can read limits (needed for feature gating)
CREATE POLICY "usage_limits_select_all"
  ON usage_limits
  FOR SELECT
  TO authenticated
  USING (true);

-- Only admins can modify
CREATE POLICY "usage_limits_admin_all"
  ON usage_limits
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_usage_limits_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER usage_limits_updated_at
  BEFORE UPDATE ON usage_limits
  FOR EACH ROW
  EXECUTE FUNCTION update_usage_limits_updated_at();

COMMENT ON TABLE usage_limits IS 'Feature limits per subscription tier';

-- =====================================================
-- 4. INVOICES TABLE
-- =====================================================

CREATE TABLE invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  stripe_invoice_id TEXT UNIQUE NOT NULL,
  stripe_subscription_id TEXT,
  amount_due INTEGER NOT NULL,
  amount_paid INTEGER NOT NULL,
  currency TEXT NOT NULL DEFAULT 'usd',
  status TEXT NOT NULL CHECK (status IN ('draft', 'open', 'paid', 'void', 'uncollectible')),
  invoice_pdf TEXT,
  hosted_invoice_url TEXT,
  paid_at TIMESTAMPTZ,
  due_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_invoices_user_id ON invoices(user_id);
CREATE INDEX idx_invoices_stripe_invoice_id ON invoices(stripe_invoice_id);
CREATE INDEX idx_invoices_status ON invoices(status);
CREATE INDEX idx_invoices_paid_at ON invoices(paid_at DESC);

-- Enable RLS
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;

-- Users can read their own invoices
CREATE POLICY "invoices_select_own"
  ON invoices
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- Admins can read all invoices
CREATE POLICY "invoices_select_admin"
  ON invoices
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- Updated at trigger
CREATE OR REPLACE FUNCTION update_invoices_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER invoices_updated_at
  BEFORE UPDATE ON invoices
  FOR EACH ROW
  EXECUTE FUNCTION update_invoices_updated_at();

COMMENT ON TABLE invoices IS 'Stripe invoice records for user billing history';

-- =====================================================
-- 5. SEED USAGE LIMITS
-- =====================================================

INSERT INTO usage_limits (plan_tier, monthly_live_call_minutes, monthly_practice_sessions, monthly_emails, monthly_analyses, features_enabled)
VALUES
  ('free', 30, 5, 3, 2, '{"live_call": true, "practice": true, "email": true, "analyzer": true}'::jsonb),
  ('individual', NULL, NULL, NULL, NULL, '{"live_call": true, "practice": true, "email": true, "analyzer": true, "advanced_analytics": false}'::jsonb),
  ('pro', NULL, NULL, NULL, NULL, '{"live_call": true, "practice": true, "email": true, "analyzer": true, "advanced_analytics": true, "priority_support": true}'::jsonb),
  ('team', NULL, NULL, NULL, NULL, '{"live_call": true, "practice": true, "email": true, "analyzer": true, "advanced_analytics": true, "priority_support": true, "team_dashboard": true, "shared_library": true}'::jsonb)
ON CONFLICT (plan_tier) DO NOTHING;

-- =====================================================
-- HELPER FUNCTIONS
-- =====================================================

-- Function to check if user has exceeded usage limits
CREATE OR REPLACE FUNCTION check_usage_limit(
  p_user_id UUID,
  p_feature TEXT,
  p_quantity NUMERIC DEFAULT 1
)
RETURNS BOOLEAN AS $$
DECLARE
  v_plan_tier TEXT;
  v_limit INTEGER;
  v_current_usage NUMERIC;
  v_period_start TIMESTAMPTZ;
BEGIN
  -- Get user's current plan tier
  SELECT s.plan_tier INTO v_plan_tier
  FROM subscriptions s
  WHERE s.user_id = p_user_id
    AND s.status IN ('active', 'trialing')
  ORDER BY s.created_at DESC
  LIMIT 1;

  -- Default to free tier if no subscription
  IF v_plan_tier IS NULL THEN
    v_plan_tier := 'free';
  END IF;

  -- Paid tiers have unlimited usage
  IF v_plan_tier IN ('individual', 'pro', 'team') THEN
    RETURN TRUE;
  END IF;

  -- Get limit for free tier
  SELECT
    CASE p_feature
      WHEN 'live-call' THEN monthly_live_call_minutes
      WHEN 'practice' THEN monthly_practice_sessions
      WHEN 'email' THEN monthly_emails
      WHEN 'analyzer' THEN monthly_analyses
    END INTO v_limit
  FROM usage_limits
  WHERE plan_tier = v_plan_tier;

  -- No limit defined = unlimited
  IF v_limit IS NULL THEN
    RETURN TRUE;
  END IF;

  -- Calculate current period start (first of current month)
  v_period_start := date_trunc('month', NOW());

  -- Get current usage for this period
  SELECT COALESCE(SUM(quantity), 0) INTO v_current_usage
  FROM usage_events
  WHERE user_id = p_user_id
    AND feature = p_feature
    AND created_at >= v_period_start;

  -- Check if adding this usage would exceed limit
  RETURN (v_current_usage + p_quantity) <= v_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION check_usage_limit IS 'Check if user can perform action without exceeding usage limits';
